>Il ne faut pas mettre tout dans le même sac!
訳注：
「なんでも同じバッグに入れないでください!」とフランス語で書かれています。



>気が散らないように、動く要素を視界の外に追い出したいユーザーがいる。
訳注:
ここで言う「気が散る」は、単に邪魔に思うという話ではありません。WCAG 2.0の達成基準2.2.2「一時停止、停止、非表示」では、動きがあったり点滅したりするコンテンツに気を取られてしまい、それ以外の部分に集中するのが困難になってしまうユーザーが存在することを指摘しています。そのようなユーザーは、動いたり点滅したりする要素を視界の外に出さないとコンテンツを読むことができません。

参考:「一時停止、停止、非表示: 達成基準 2.2.2 を理解する」
http://waic.jp/docs/UNDERSTANDING-WCAG20/time-limits-pause.html




>このFont Face Observerを使えば、フォントリソースの読み込みを監視して読み込み完了を待つ処理を、シンプルなPromiseベースのインターフェイスで以下のように書くことができます。
訳注:
PromiseはJavaScriptの非同期処理に使われるオブジェクトです。FontFaceOvserver.check() は Promiseオブジェクトを返し、Promise.then() メソッドの引数として完了時の処理、エラー時の処理、処理中の処理を渡すことができるようになっています。



>そのためには、フォントはBase64でエンコードし、当該のスタイルシートに埋め込む必要があります。
訳注:
日本語のフォントセットは一般的にかなり大きいため、Base64エンコードしてCSSに直接埋め込む方法はあまり現実的ではないかもしれません。



>JavaScriptがまったく使えない場合でも、<noscript>があるおかげで、とりあえずCSSは読み込まれます。
訳注:
ただしこの場合、エンハンスメントは機能せず、コンテンツのロードが終わる前にフォントを読み込みます。



>DOCTYPEでドキュメントの種類をブラウザに伝えたら（HTML5なら上の例のようになります）、次は<html>要素のlang属性でドキュメントの言語を指定します。
訳注:
厳密には、HTML5のDOCTYPEは文書の種類を伝えるためのものではありません。HTML4までのHTMLはSGMLベースのマークアップ言語だったため、SGMLのルールにより、冒頭に文書型宣言 (Document type declaration) を書いて文書の種類を宣言する必要がありました。しかしHTML5はもはやSGMLではありません。HTML5でも文書の先頭にDOCTYPEを書きますが、これはSGMLの文書型宣言ではなく、DOCTYPEを見て挙動を変えるブラウザとの互換性のために書いているに過ぎません。そのため、仕様でも "Document type declaration" ではなく、単に "DOCTYPE" と呼ばれています。
https://html.spec.whatwg.org/multipage/syntax.html#the-doctype



>特にFOIT（Flash of Invisible Text）は避けた方が賢明です。フォントのリソースがいつまでも読み込まれないと（実際よくあることです!）、デバイスやブラウザによってはページのテキストが全く表示されない状態で止まってしまいます。
訳注:
フォントの読み込みに時間がかかる場合、特に何もしないと、テキストはまずデフォルトのフォントで表示されます。その後、フォントの読み込みが終わった時点で、該当のフォントに変化しますが、読み込み完了までの間はデフォルトのフォントが見えていることになります。このとき、デフォルトのフォントが一瞬見えてしまう現象を、一般に FOUT (Flash of Unstyled Text) と呼びます。この現象への対策として、フォントの読み込み中はテキストを非表示にしておき、読み込みが完了してから表示させるという手法があります。この場合、テキストが何も表示されていない状態が一瞬見えることになるため、これを FOIT(Flash of Invisible Text) と呼んでいます。


>それよりも、最初から完全に柔軟なデザインを作り、コンテンツのレイアウトが切り替わるところだけにブレイクポイントを挿入すべきです――すなわち、コンテンツブレイクポイント、あるいはトゥイークポイントということになります。

訳注:
トゥイーク (Tweak) は微調整するという意味です。「ブレイクポイント」という言葉に対して、"Break"と言うほど派手に変化するわけではない、微調整にとどまる変化をさせることをこう呼んでいます。

参考:
Tweakpoints | Adactio: Journal
https://adactio.com/journal/6044/
Media Query-less Design, Content-based Breakpoints & Tweakpoints
http://dmolsen.com/2013/03/05/media-query-less-design-content-based-breakpoints-tweakpoints/



>晴眼のキーボードユーザーには、スクリーンリーダーのようなショートカットの機能が提供されていません。ナビゲーションや他のヘッダーコンテンツをスキップする機能は、彼らのためのものなのです。
訳注:
基本的な考え方はこのとおりですが、目の見えるキーボードユーザーは何らかの代替マウスの機能を使っていることが多く、コンテンツ内のスキップリンクを利用するニーズはあまりないのではないかという議論もあります。

参考:
JIS X 8341-3:2010 達成基準7.2.4.1を満たす条件に関する意見募集
http://waic.jp/news/20130107.html
JIS X 8341-3:2010 達成基準7.2.4.1を満たす条件に関する意見募集の結果について
http://waic.jp/news/20130422.html



>著者側のCSSがなければ、Webページはこのようにふるまいます。CSSを含める場合でも、この基本的なふるまいを尊重すべきでしょう
訳注: 
CSSには「カスケード」と呼ばれる仕組みがあり、著者(Author, コンテンツ制作者)、ユーザー、ユーザーエージェントの三者がそれぞれスタイルを定義することができます。コンテンツ制作者がCSSを用意していない場合、ブラウザ側が用意しているスタイルがそのまま使われます。また、それらに加えて、ユーザーが独自のスタイルを定義することもできます。

CSS Cascading and Inheritance Level 3 - 6.1. Cascading Origins
http://www.w3.org/TR/css3-cascade/#cascading-origins



>拡張機能（脚注14）を使えばオリジナルのCSSをドメインベースで適用できます。
訳注:
CSSには「カスケード」と呼ばれる仕組みがあり、著者、ユーザー、ユーザーエージェントの三者がそれぞれスタイルを定義することができます。多くのブラウザには「ユーザースタイルシート」と呼ばれる機能があり、ユーザー側で定義したCSSで著者側のスタイルを上書きできるようになっています。しかし、その機能を持たないブラウザもありますし、機能があっても設定が大変だったり、全てのサイトに同一のユーザースタイルシートが適用されてしまうといった問題があり、かなり使いにくい側面があります。この拡張機能を使えば、ドメインごとにユーザースタイルシートを適用できるようになり、特定サイトのスタイルだけを変更することが簡単にできるようになります。

