<?xml version='1.0' encoding='UTF-8' ?>
<!--?xml version="1.0" encoding="UTF&#45;8"?--><html xml:lang="ja" xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8"/><title>ドキュメント全体 | インクルーシブHTML+CSS &amp; JavaScript</title><link rel="stylesheet" href="css/book.css" type="text/css"/><meta name="EPB-UUID" content="24CC751A-5435-483D-851C-00DC23A33E17"/></head><body><div class="body"><h1>ドキュメント全体</h1><p>この後の章では個々のインターフェイスパターン――モジュールあるいはコンポーネントとして確立された慣習――を詳しく見ていくことになりますが、その前に、それらのパターンが最終的にWebドキュメントに属することを理解しておかなければなりません。HTMLページは形もサイズも実にさまざまにでき、その中身にはあらゆるパターンの組み合わせを入れることができます。しかし、ドキュメント全体のレベルで従うべきベストプラクティスがいくつか存在します。</p><p>この章の目的は、究極のひな形を探し求めることではなく、インクルーシブなインターフェイスの親となるWebページを適切な設定にすることです。</p><h2>DOCTYPE</h2><p>昔ながらの静的なリソースであれ、シングルページアプリケーションであれ、Webページがドキュメントであることは間違いありません。その証拠に、コードの先頭の行には "DOC" という文字列が出現します。<code>&lt;!DOCTYPE html&gt;</code>ですね。このことは、立体的で動きのあるインターフェイスをデザインするときでも、結局はコンテンツをブラウザウィンドウの中に入れているのだという事実を思い出させてくれます。ブラウザ自体もひとつのインターフェイスだということを忘れてはいけません。ユーザーはさまざまな方法で設定や拡張を行うことができます――コンテンツの解釈を助けるために、スクリーンリーダーのようなサードパーティの支援技術を導入することもあります。あなたがデザインするインターフェイスはあくまでブラウザのインターフェイスに付随するものであり、ユーザー側のさまざまな設定や構成に対応できなければなりません。</p><p><img src="images/interface_interface.png" alt="ブラウザ上のすべてのインターフェイス要素のうち、あなたがデザインするインターフェイスに「あなたのインターフェイス」とラベルが付けられている図。"/><br/><em>ユーザーがブラウザを開いたときに使用するインターフェイスは、あなたがデザインするインターフェイスだけではありません。</em></p><p>加えて、前述したDOCTYPE宣言を<em>省略</em>してしまうと、ユーザーにとって予期せぬ異常な動作が生じる可能性があります。DOCTYPEが明確でないと、ブラウザはコンテンツをどう解釈したらよいか分からず、<a href="https://developer.mozilla.org/en-US/docs/Quirks_Mode_and_Standards_Mode"><span class="link">非対応の不適合なモード、いわゆる<span class="italic-link">Quirksモード</span></span></a>で表示してしまうことがあります。その場合、レイアウトやインタラクションが不安定になることがあります。Webページのテスト時におかしなことが起きたら、私はまっさきにDOCTYPEを確認します。それで何度も痛い目にあってきましたから。</p><h2>lang属性</h2><p>DOCTYPEでドキュメントの<em>種類</em>をブラウザに伝えたら（HTML5での方法は先に挙げたとおりです）、次は<code>&lt;html&gt;</code>要素の<code>lang</code>属性でドキュメントの言語を指定します。言語といっても、HTMLかXHTMLかという話ではありません。英語かフランス語かという話です。</p>
        <div class="translator_note" id="translator_note0277"><h3>訳註</h3><p>厳密には、HTML5のDOCTYPEは文書の種類を伝えるためのものではありません。HTML4までのHTMLはSGMLをベースにしていたため、冒頭に文書型宣言 (Document type declaration) を書いて文書の種類を宣言する必要がありました。しかしHTML5はもはやSGMLではありません。HTML5でも文書の先頭にDOCTYPEを書きますが、これはSGMLの文書型宣言ではなく、DOCTYPEを見て挙動を変えるブラウザとの互換性のために書いているに過ぎません。そのため、仕様でも "Document type declaration" ではなく、単に "DOCTYPE" と呼ばれています。</p><h4>参考</h4><ul><li><a href="https://html.spec.whatwg.org/multipage/syntax.html#the-doctype">HTML Living Standard - 12.1.1 The DOCTYPE</a></li></ul></div>
        <pre><code class=" language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation">=</span>"en"</span></span> <span class="token comment">&lt;!-- 言語を英語に設定 --&gt;</span></code></pre><p>しばしば省略されますが、Webページの言語を明示することは、それなりに重要です。検索エンジンがインデクシングしやすくなるほか、ユーザーがGoogleの<a href="https://cloud.google.com/translate/docs"><span class="link">Translate API</span></a>のようなサードパーティツールを使って翻訳することも容易になります。また、ユーザーがページの言語で<em>入力</em>する際にも役立ちます。たとえばFirefoxでは、<code>&lt;textarea&gt;</code>でスペルミスをハイライト表示する際の辞書が切り替えられます。</p><p>おそらく最もわかりやすいのは、言語が明示されていないページ――あるいは間違った言語が指定されているページ――では、スクリーンリーダーを使用したときに適切な合成音声プロファイルが選択されないことです。つまり、もし<code>&lt;html lang="en"&gt;</code>が存在するのにテキストが実際にはフランス語である場合、Jaquesと呼ばれるフランス語の音声プロファイルによる流暢なフランス語の発音で読まれるべきところで、Jackという英語の音声プロファイルによる下手なフランス人のモノマネを聞かされるはめになります。</p><pre><code class=" language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>Il ne faut pas mettre tout dans le même sac!<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span></code></pre>
        <div class="translator_note" id="translator_note0286"><h3>訳註</h3><p>「なんでも同じバッグに入れないでください!」とフランス語で書かれています。</p></div>
        <p>適切な言語が明示されていれば、スクリーンリーダーや点字ディスプレイにとって有益ですし、さらに、ブラウザが適切な文字セットを含むシステムフォントを選択することもできるようになります。たとえば、<code>lang="zh-Hans”</code>と指定すると、簡体字中国語のフォントで表示されます。不適切なフォントで文字化けしたテキストは、<em>いくらなんでも</em>、閲覧者に最適なインクルーシブなものとは言えません。</p><p><code>&lt;body&gt;</code>内の子要素に<code>lang</code>属性を指定して、1つのページの中で言語を切り替えることも可能です。たとえば、英語のページの中でフランス語を引用したい場合は、以下のようにします。</p><pre><code class=" language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>blockquote</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation">=</span>"fr"</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>Ceci n’est pas une pipe<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>— <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>cite</span><span class="token punctuation">&gt;</span></span>René Magritte<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>cite</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>blockquote</span><span class="token punctuation">&gt;</span></span></code></pre><p>CSSの<code>:lang</code>擬似クラスを使えば、フランス語が指定されているすべてのセクションを選択し、フランス語に適したフォントを適用して読みやすくすることもできます。</p><pre><code class=" language-css"><span class="token selector">:lang(fr) </span><span class="token punctuation">{</span>
    <span class="token property">font-family</span><span class="token punctuation">:</span> フランス語フォント, フォールバック用フォント, sans-serif<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p><code>lang</code>属性は、Webドキュメントに書かれたコンテンツの読みやすさ、翻訳のしやすさ、互換性を向上させて、世界中の人に開かれたものにできるのです。<code>lang</code>属性を指定するのは簡単なことですので、ぜひ使ってみてください。</p><h2>レスポンシブデザイン</h2><p>レスポンシブデザインはインクルーシブデザインの重要な要素のひとつです。機敏に変化して環境に適応できるようにドキュメントをデザインすれば、市場に次から次へと登場するさまざまなデバイスに対応できます。本書ではレスポンシブデザインについて詳述はしませんが、ぜひ知っておきたい、インクルーシブデザインを支えるレスポンシブデザインの原則をいくつか紹介します。</p><h3>コンテンツのブレイクポイント</h3><p>真にインクルーシブな体験を作りたいなら、特定のデバイスの特定のビューポートを想定する（デバイスのビューポートのサイズをブレイクポイントとして採用する）のは無駄が多すぎます。それぞれのデバイスに対応するには、あまりにもビューポートのバリエーションが多すぎるのです。それよりも、最初から完全に柔軟なデザインを作り、コンテンツのレイアウトが切り替わるところだけにブレイクポイントを挿入すべきです――すなわち、<em>コンテンツブレイクポイント</em>、あるいは<em>トゥイークポイント</em>ということになります。</p>
<div class="translator_note" id="translator_note0307"><h4>訳註</h4><p>トゥイーク (Tweak) は微調整するという意味です。「ブレイクポイント」という言葉に対して、"Break"と言うほど派手に変化するわけではない、微調整にとどまる変化をさせることをこう呼んでいます。</p><h5>参考</h5><ul><li><a href="https://adactio.com/journal/6044/">Tweakpoints | Adactio: Journal</a></li><li><a href="http://dmolsen.com/2013/03/05/media-query-less-design-content-based-breakpoints-tweakpoints/">Media Query-less Design, Content-based Breakpoints &amp; Tweakpoints</a></li></ul></div>
<p>コンテンツブレイクポイントを採用すれば、手作業でテストできないものも含んだ非常に幅広いデバイスで、レイアウトをより確実に成立させることができます。あなたに予知能力があって、すべてのユーザーの端末の設定を予測できるのでない限り、これが唯一の方法です。</p><p>コンテンツブレイクポイントを検討する際は、Firefoxの<a href="https://developer.mozilla.org/en/docs/Tools/Responsive_Design_Mode"><span class="link">レスポンシブデザインモード</span></a>が便利です。<em>Cmd</em> + <em>Option</em> + <em>M</em>キーを押してみてください。すると、コンテンツがぶつかったり、重なったり、折り返したりするところまで、シミュレートされたビューポートを徐々にリサイズすることができます。このとき、レスポンシブデザインモードのインターフェイスに現在のサイズが表示されるため、これを記録すれば、そのブレイクポイントがわかります。</p><p><img src="images/viewports.png" alt="ビューポートの幅を表す図。小さい実線のボックスは想定される最小のビューポートを表し、そこから横に伸びる大きい点線のボックスは無限に引き伸ばしたビューポートを表している。"/><br/><em>レスポンシブデザインはあらゆる幅に対応しているべきです。ただしそれは、あらゆる幅に対応したブレイクポイントが必要になるということではありません。</em></p><p>シンプルなインターフェイスは使いやすい上に、ブレイクポイントの管理の手間がはるかに少なくて済みます。大ざっぱに言ってしまえば、どんな要素も幅や高さを固定すべきではありません。ボックスに柔軟性があれば、同じコンテンツでさまざまなスペースに対応できます。著者側のCSSがなければ、Webページはそのようにふるまいます。CSSを含める場合でも、この基本的なふるまいを尊重すべきでしょう。</p>
<div class="translator_note" id="translator_note0318"><h4>訳註</h4><p>CSSには「カスケード」と呼ばれる仕組みがあり、著者（Autho, コンテンツ制作者）、ユーザー、ユーザーエージェントの三者がそれぞれスタイルを定義することができます。コンテンツ制作者がCSSを用意していない場合、ブラウザ側が用意しているスタイルがそのまま使われます。</p><h5>参考</h5><ul><li><a href="https://www.w3.org/TR/css3-cascade/#cascading-origins">CSS Cascading and Inheritance Level 3 - 6.1. Cascading Origins</a></li></ul></div>
<h3>ピンチによる拡大縮小を可能にする</h3><p><code>viewport</code>メタタグを置くことで、魔法のようにレスポンシブデザインが有効になります。しかしこのタグは同時に、ユーザーによるコンテンツの拡大縮小を無効にして、魔法のように体験を<em>損なう</em>ことが少なくありません。私がTwitterでフォロワーを対象に行った、デザイナーが犯すインクルージョン関連の最大のミスは何か？という調査では、「携帯端末でピンチによる拡大縮小を禁止している」が群を抜いて1位でした。</p><p>わかりやすい例をお見せしましょう。1つめは不適正な例、2つめは正しい例です。</p><pre><code class=" language-markup"><span class="token comment">&lt;!-- これは使わないでください --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span>"viewport"</span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span>"width<span class="token punctuation">=</span>device-width, initial-scale<span class="token punctuation">=</span>1.0, minimum-scale<span class="token punctuation">=</span>1.0, maximum-scale<span class="token punctuation">=</span>1.0, user-scalable<span class="token punctuation">=</span>no"</span><span class="token punctuation">&gt;</span></span>

<span class="token comment">&lt;!-- これを使ってください --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span>"viewport"</span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span>"width<span class="token punctuation">=</span>device-width, initial-scale<span class="token punctuation">=</span>1.0"</span><span class="token punctuation">&gt;</span></span></code></pre><p>エイドリアン・ロセッリ（Adrian Roselli）がリストアップした、<a href="http://adrianroselli.com/2015/10/dont-disable-zoom.html"><span class="link">拡大縮小を無効にするとインクルージョンが損なわれる理由</span></a>は以下のとおりです。</p><p class="list"><span class="bullet">•</span>テキストが小さすぎて読めない恐れがある。</p><p class="list"><span class="bullet">•</span> 画像の細部を見たいユーザーがいるかもしれない。</p><p class="list"><span class="bullet">•</span> テキストを大きくすると、コピー&amp;ペーストしたい単語を選択しやすくなる。</p><p class="list"><span class="bullet">•</span> 気が散らないように、動く要素を視界の外に追い出したいユーザーがいる。</p><p class="list"><span class="bullet">•</span> 開発者のレスポンシブデザインの作りかたがまずいと、ページを利用するために拡大縮小が必要になる（これがよくあるのです!）。</p><p class="list"><span class="bullet">•</span> ブラウザのバグや奇妙なふるまい（これも要するにバグ）のせいで、デフォルトの表示倍率では正しく表示されないことがある。</p><p class="list last-item"><span class="bullet">•</span>ピンチイン・ピンチアウトの動作が拡大縮小以外の意味に解釈されるとユーザーが混乱する。</p>
<div class="translator_note" id="translator_note0329"><h4>訳註</h4><p>ここで言う「気が散る」は、単にじゃまに思うという話ではありません。WCAG 2.0の達成基準2.2.2「一時停止、停止、非表示」では、動きがあったり点滅したりするコンテンツに気を取られてしまい、それ以外の部分に集中するのが困難になってしまうユーザーが存在することを指摘しています。そのようなユーザーは、動いたり点滅したりする要素を視界の外に出さないとコンテンツを読むことができません。</p><h5>参考</h5><ul><li><a href="http://waic.jp/docs/UNDERSTANDING-WCAG20/time-limits-pause.html">「一時停止、停止、非表示: 達成基準 2.2.2 を理解する」</a></li></ul></div>
<p>前述したように、ブラウザ自体もインターフェイスです。インクルーシブデザインを実現するためには、デザイナーは世話役に徹し、提供するコンテンツの表示やインタラクションをユーザーが設定することを許すべきです。デザイナーが決めることが少ないほど、ユーザーが決められることが多くなります。</p><p>ユーザーが拡大縮小したときにレイアウトが崩れてしまうのは、ユーザーのせいではなく<em>デザイン</em>の問題です。拡大縮小を禁止したところで、何の解決にもなりません。経験からいって、固定配置の要素、特に<code>position:fixed</code>で固定したものは問題を起こしがちです。コンテンツを拡大したとき、画面の特定の場所に固定された要素は、他のコンテンツを覆い隠して読めなくしてしまいます。</p><h2>フォントサイズ</h2><p>デスクトップのブラウザでは、デフォルトのフォントサイズはたいてい16pxです。デフォルトが大きめなのには理由があります。他のサイズでは、特に視力が低下した高齢者など、さまざまなユーザーを遠ざけてしまう恐れがあるからです。「でも私のサイトのユーザーは若くて流行に敏感な人たちだから！」と言う人もいるでしょう。なるほど、そうかもしれません。しかし、フォントサイズが大きめだからと言って、若くて眼力の鋭いユーザーが<em>気分を害する</em>とは思えません。インクルーシブデザインで重要なのは、特定のグループをターゲットにすることではなく、特定のグループを恣意的に<em>排除しない</em>ことです。排除しても、得るものは何ひとつありません。</p><p>フォントサイズをパーセンテージ指定する慣習は、もうおなじみかもしれません。ルート（<code>&lt;html&gt;</code>）要素で以下のようにします。</p><pre><code class=" language-css"><span class="token selector">html </span><span class="token punctuation">{</span>
    <span class="token property">font-size</span><span class="token punctuation">:</span> 100%<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>この例の場合、<em>もし</em>ユーザーがオペレーティングシステムやブラウザの設定（たとえばFirefoxの場合は<em>［環境設定（またはオプション）］→［コンテンツ］</em>）でフォントサイズを手動で調整していないなら、<code>100%</code>は<code>16px</code>になります。つまり、この<code>100%</code>は「デフォルトサイズまたはユーザーが選択したサイズの100%」を意味します。一方、ルート要素でフォントサイズを明示的に16pxに設定した場合は、ユーザー側でフォントサイズを自由に調整できなくなります。</p><pre><code class=" language-css"><span class="token selector">html </span><span class="token punctuation">{</span>
    <span class="token comment">/* この指定は使わないでください */</span>

    <span class="token property">font-size</span><span class="token punctuation">:</span> 16px<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p><em>Cmd</em>（または<em>Ctrl</em>）キーと<em>＋</em>キーを同時に押してページ全体を拡大するユーザーが増えているのはたしかです。しかし、最近のブラウザやオペレーティングシステムもテキストのみのサイズ変更をサポートしているため、それに対応しておくべきでしょう。また、ユーザーが文字サイズを変更した際、<code>font-size</code>、<code>padding</code>、<code>margin</code>が協調して変化するように、それぞれの値を相対単位の<code>rem</code>や<code>em</code>、<code>ch</code>などで設定する必要があります。</p><p>そうすれば、メディアクエリの複雑さも大幅に軽減されます。たとえば次の例では、<code>p</code>の<code>line-height</code>と<code>margin</code>は<code>font-size</code>に相対的に設定されているため、両者のサイズのバランスは維持されます。すべてを相対的に設定しておけば、ルートのフォントサイズを調整するだけで、ページ全体のサイズを簡単に調整できます。以下のメディアクエリの例をご覧ください。</p><p>(<strong>注：</strong>ユーザーが指定したフォントサイズに対して相対的に正しい位置で確実にメディアクエリが実行されるようにするために、単位にemを使っています。ゼル・リュウ（Zell Liew）が「<a href="http://zellwk.com/blog/media-query-units/"><span class="link">PX, EM or REM Media Queries?</span></a>」で実証しているように、remではSafariで問題が起きます。)</p><pre><code class=" language-css"><span class="token selector">p </span><span class="token punctuation">{</span>
    <span class="token property">margin</span><span class="token punctuation">:</span> 1.5rem 0<span class="token punctuation">;</span>
    <span class="token property">font-size</span><span class="token punctuation">:</span> 1rem<span class="token punctuation">;</span>
    <span class="token property">line-height</span><span class="token punctuation">:</span> 1.5<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token atrule">@media (max-width: 60em) </span><span class="token punctuation">{</span>
    <span class="token selector">html </span><span class="token punctuation">{</span>
        <span class="token property">font-size</span><span class="token punctuation">:</span> 80%<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>たとえば<code>&lt;h2&gt;</code> に<code>font-size:2rem;</code>が指定されていると、ルートで設定されているサイズの2倍の大きさになります。ユーザーがFirefoxの<em>[環境設定（またはオプション）]→[コンテンツ]</em>でデフォルトのフォントサイズを20pxに設定している場合、<code>2rem</code>は20×2、つまり40pxを意味します。CSSプリプロセッサでremをピクセルに変換するという過ちを犯さないように注意してください。最終的にブラウザが解析するコンパイル後のCSSで、計算後の数値が使われるはめになります。</p><h3>ビューポートを基準とする単位</h3><p>ビューポートを基準とする単位を使えば、ビューポートの高さ（<code>vh</code>）と幅（<code>vw</code>）に合わせてテキストのサイズを調整できます。つまり、前出のコード例のようなメディアクエリを用いずにレスポンシブなテキストを使用できるというわけです。</p><p>ただし、1つ注意点があります。ビューポートの単位が指定されている要素は、ページ全体のズームでは拡大縮小<em>されない</em>ということです。ズームを再び機能させるには、ビューポートの単位の値にemベースの値を加算するという方法があります。この方法には、ページの最小フォントサイズを確保できるというメリットもあります。つまり、1em + (0× 1vw) となっても1emを確保できるということです。</p><pre><code class=" language-css"><span class="token selector">html </span><span class="token punctuation">{</span> <span class="token property">font-size</span><span class="token punctuation">:</span> calc(1em + 1vw)<span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><p>このアルゴリズムでは、すべてのテキストがビューポートに対して相対的に拡大縮小していきます。アクセシビリティを犠牲にすることなく、コードを書く手間を大幅に軽減できます。</p><p>本書の執筆時点で、ビューポートの単位をサポートしていないモダンブラウザはOpera Miniだけです。ご心配なく。<code>font-size: calc(1em+1vw);</code> という記述はプログレッシブエンハンスメントになっています。この指定が認識できない場合、ブラウザはユーザーエージェントのデフォルトにフォールバックします。言い換えれば、Opera Miniでは、ユーザーがあらかじめ設定しているお好みのサイズで本文テキストが表示されるということです。</p>
<div class="translator_note" id="translator_note0383"><h4>訳註</h4><p>ブラウザにとって未知の単位が指定されている場合、不正な値が指定されているものとして扱われます。CSSのルールでは、不正な値が指定されている場合、その宣言を無視することになっています。その宣言が無視された結果、他に有効なスタイルがなければユーザーエージェントのデフォルトが使われますが、他のスタイルが適用できる場合はそちらにフォールバックされます。たとえば、以下のように書くこともできます。</p><pre class="CSS">html{
font-size: 1.1em;
font-size: calc(1em+1vw);
}
</pre><p>この場合、vwを認識しないユーザーエージェントには 1.1em が適用されます。</p><h5>参考</h5><ul><li><a href="https://www.w3.org/TR/CSS22/syndata.html#parsing-errors">CSS2 4.2 Rules for handling parsing errors</a></li></ul></div>
<h2>プログレッシブエンハンスメント</h2><p>レスポンシブデザインと同じく、インクルーシブデザインの土台となるのがプログレッシブエンハンスメントです。JavaScriptをオフにしているユニコーンのように希少なユーザーでも使えるWebアプリケーションを作るかのような骨の折れる仕事だ、などと言われることが多いのですが、実際にはもっと広い意味があります。</p><p>プログレッシブエンハンスメントの目的は、さまざまな回線状況やスクリプト処理の失敗にも対応できるコンテンツの強固な基盤を、合理的かつ堅牢な形で構築することです。単純にJavaScriptやCSSが全く利用できないという話だけでなく、いつどのような理由で利用できなくなったか、どのくらいのあいだ利用できないのか、そしていつどういう順序で利用できるように<em>なった</em>のか、といったさまざまなことが関係してきます。</p><p>本書で紹介するパターンは、整形式のセマンティックHTMLの構造をベースにし、CSSとJavaScriptでエンハンスメントしたものです。可能であれば、統合されたJavaScriptウィジェットを、きちんと構造化された静的なコンテンツとインタラクティブなフォーム要素に分解します。そうすることで、JavaScriptやCSSを――一時的に、あるいは常時――利用しないユーザーでも、コンテンツをたどったり利用したりできるようになります。JavaScriptが使えるかどうかに関係なく、セマンティックHTMLは支援技術のユーザーにインクルーシブな体験を保証し、インタラクションの動作をより予測可能で効率的なものにします。</p><p><img src="images/enhancement_stages.png" alt="プログレッシブエンハンスメントの段階を示す図。読み込みのプロセスにおいて、まずHTMLとそのコンテンツを取得する。次にCSSを取得するが、コンテンツは維持される。最後にJavaScriptが加わるが、コンテンツは依然として維持される。"/><br/><em>エンハンスメントはすばらしいですが、本当に必要な箇所だけで使いましょう。</em></p><p>プログレッシブエンハンスメントの手法を使う際、スクリプトはドキュメントの最後、終了タグ<code>&lt;/body&gt;</code>の直前に入れます。これによって、スクリプトが実行される前に、メインのDOMコンテンツをレンダリングできるようになります。</p><pre><code class=" language-markup"><span class="token script"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token comment">// TODO：エンハンスメント</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span></code></pre><h2>アセットの管理</h2><p>ドキュメントのセットアップという観点では、ページのコンテンツを強化するためのリソースが逆にコンテンツの妨げにならないようにすることが重要です。ネットワークの速度が遅い場合は、コンテンツができるだけ早く表示されるようにしなければなりません。コンテンツこそ、ユーザーがページにアクセスする目的なのですから。</p><p>Webフォントは一般的に大きいアセットなので、エンハンスメントで処理すべきです。特にFOIT（Flash of Invisible Text）は避けた方が賢明です。フォントのリソースがいつまでも読み込まれないと（実際よくあることです！）、デバイスやブラウザによってはページのテキストが全く表示されない状態で止まってしまいます。これでは、回線が不安定なユーザーにとってはとてもインクルーシブとは言えません。</p>
<div class="translator_note" id="translator_note0406"><h3>訳註</h3><p>フォントの読み込みに時間がかかる場合、特に何もしないと、テキストはまずデフォルトのフォントで表示されます。その後、フォントの読み込みが終わった時点で、該当のフォントに変化しますが、読み込み完了までの間はデフォルトのフォントが見えていることになります。このとき、デフォルトのフォントが一瞬見えてしまう現象を、一般に FOUT (Flash of Unstyled Text) と呼びます。この現象への対策として、フォントの読み込み中はテキストを非表示にしておき、読み込みが完了してから表示させるという手法があります。この場合、テキストが何も表示されていない状態が一瞬見えることになるため、これを FOIT(Flash of Invisible Text) と呼んでいます。</p></div>
<p>ポイントは、先にページを読み込んで<em>から</em>、<code>onload</code>イベントを分岐点にしてフォントを読み込むようにすることです。そのためには、フォントはBase64でエンコードし、当該のスタイルシートに埋め込む必要があります。<a href="http://keithclark.co.uk/articles/loading-css-without-blocking-render/"><span class="link">キース・クラーク（Keith Clark）の例</span></a>では、<code>&lt;link&gt;</code>の<code>onload</code>ハンドラでメディアタイプを<code>none</code>から<code>all</code>に切り替えています。JavaScriptがまったく使えない場合でも、<code>&lt;noscript&gt;</code>があるおかげで、とりあえずCSSは読み込まれます。</p>
<div class="translator_note" id="translator_note0409"><h3>訳註</h3><p>日本語のフォントセットは一般的にかなり大きいため、単純にBase64エンコードしてCSSに埋め込むのは現実的ではないかもしれません。後述の「フォントのサブセット化」も参照してください。</p></div>
<pre><code class=" language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span>"stylesheet"</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span>"fonts.css"</span> <span class="token attr-name">media</span><span class="token attr-value"><span class="token punctuation">=</span>"none"</span> <span class="token attr-name">onload</span><span class="token attr-value"><span class="token punctuation">=</span>"if(media!<span class="token punctuation">=</span>'all')media<span class="token punctuation">=</span>'all'"</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>noscript</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span>"stylesheet"</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span>"fonts.css"</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>noscript</span><span class="token punctuation">&gt;</span></span></code></pre><p>Base64でエンコードしたフォントは<code>@font-face</code>宣言ブロックで以下のように指定します。</p><pre><code class=" language-css"><span class="token atrule">@font-face</span> <span class="token punctuation">{</span>
    <span class="token property">font-family</span><span class="token punctuation">:</span> Merriweather<span class="token punctuation">;</span>
    <span class="token property">font-style</span><span class="token punctuation">:</span> normal<span class="token punctuation">;</span>
    <span class="token property">font-weight</span><span class="token punctuation">:</span> 400<span class="token punctuation">;</span>
    <span class="token property">src</span><span class="token punctuation">:</span> local(<span class="token string">'Merriweather'</span>), <span class="token url">url('data:application/x-font-woff;charset=utf-8;base64...')</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<div class="translator_note" id="translator_note0411"><h3>訳註</h3><p>ただし、スクリプト無効の場合にはエンハンスメントが機能せず、コンテンツのロードが終わる前にフォントを読み込むため、待ち時間が発生することになります。</p></div>
<p>JavaScriptに少し依存することになりますが、より包括的なFOIT対策を<a href="https://github.com/bramstein/fontfaceobserver"><span class="link">ブラム・スタイン（Bram Stein）が提供しています</span></a>。このFont Face Observerを使えば、フォントリソースの読み込みを監視して読み込み完了を待つ処理を、シンプルなPromiseベースのインターフェイスで以下のように書くことができます。</p><pre><code class=" language-javascript"><span class="token keyword">var</span> observer <span class="token operator">=</span> <span class="token keyword">new</span> FontFaceObserver<span class="token punctuation">(</span><span class="token string">'MyWebSerif'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

observer<span class="token punctuation">.</span>check<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>then<span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    document<span class="token punctuation">.</span>documentElement<span class="token punctuation">.</span>className <span class="token operator">+</span><span class="token operator">=</span> <span class="token string">"fonts-loaded"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<div class="translator_note" id="translator_note0420"><h3>訳註</h3><p>PromiseはJavaScriptの非同期処理に使われるオブジェクトです。FontFaceOvserver.check() は Promiseオブジェクトを返し、Promise.then() メソッドの引数として完了時の処理、エラー時の処理、処理中の処理を渡すことができるようになっています。</p></div>
<p>あとは単純に、上記の<code>.fonts-loaded</code>クラスセレクタを使って、CSSで該当のフォントを指定するだけです。</p><pre><code class=" language-css"><span class="token selector">html </span><span class="token punctuation">{</span>
    <span class="token comment">/* システムフォント指定、フォールバックつき */</span>
    <span class="token property">font-family</span><span class="token punctuation">:</span> MySystemSerif, serif<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token selector">html.fonts-loaded </span><span class="token punctuation">{</span>
    <span class="token comment">/* Webフォント指定、フォールバックつき */</span>
    <span class="token property">font-family</span><span class="token punctuation">:</span> MyWebSerif, MySystemSerif, serif<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>FOITを避けるためには、FOUT (Flash of Unstyled Text) と呼ばれる、比較的軽微な問題を許容する必要があります。なお、「Flash of Unstyled Text」というのは理不尽な呼び方です。なぜなら、すべてのフォントはスタイルを持っている（つまり、独自の字形を持っている）からです。ただし、Webフォントが読み込まれたタイミングでシステムフォントがWebフォントに置き換わると、ページの表示位置が突然飛んで、どこを読んでいたかわからなくなってしまう可能性があります。これはそもそも片方のフォントがもう片方のフォントより大きかったり小さかったりして、行の折り返し位置が変わるためです。</p><p>この望ましくない現象を軽減する一番の方法は、Webフォントに近い基本寸法（メトリクス）のフォールバックシステムフォントを選択することです。</p><h2>フォントのサブセット化</h2><p>広範な国際文字セットをサポートしているフォントはインクルーシブなフォントといえます。しかし、必要な文字のサブセットだけを含めるようにしないと、ユーザー側にパフォーマンスの問題が生じかねません。フォント全体のファイルサイズと、必要な文字、たとえばアンパサンド記号（&amp;）のみをサブセット化した場合のファイルサイズは、それこそ桁違いです！</p><p><a href="https://www.google.com/fonts"><span class="link">Google Fonts</span></a>を使用する場合は、URLに<code>text</code>パラメータを付けて、必要な文字のリストを指定できます。たとえば、<code>&lt;h2&gt;</code>見出しで特定フォントの大文字だけを使うとわかっている場合、link要素を以下のように書くことができます。</p><pre><code class=" language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span>"https://fonts.googleapis.com/css?family<span class="token punctuation">=</span>Roboto:900&amp;text<span class="token punctuation">=</span>ABCDEFGHIJKLMNOPQRSTUVWXYZ"</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span>"stylesheet"</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span>"text/css"</span><span class="token punctuation">&gt;</span></span></code></pre><p>独自のフォントを使用する場合は、まず<a href="http://www.fontsquirrel.com/tools/webfont-generator"><span class="link">Font Squirrelのジェネレータ</span></a>を使ってフォントをサブセット化します。CSSのフォントスタックの仕組みでは、最優先フォントでサポートされていない文字はフォールバックによって補われます。実際のところ、システムフォントは多くの文字にマッチし、普段あまり使われない文字も提供できます。そのため、Webフォントを大幅にサブセット化しても問題ないというわけです。Font Squirrelのジェネレータを使用すれば、Webフォントの文字セットを、たとえば<a href="https://en.wikipedia.org/wiki/Basic_Latin_(Unicode_block)"><span class="link">Unicodeの基本ラテン文字のブロック</span></a>だけに限定することができます。</p><pre><code class=" language-css"><span class="token selector">body </span><span class="token punctuation">{</span>
    <span class="token property">font-family</span><span class="token punctuation">:</span> サブセット化したWebフォント, システムフォント, sans-serif<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><h2><code>&lt;title&gt;</code> 要素</h2><p><code>&lt;title&gt;</code>要素は<code>&lt;head&gt;</code>要素の中にあり、皆さんもよくご存じのように、ブラウザはこのテキストをタブのラベルとして使います。また、検索エンジンは、検索結果のリンクにこのテキストを使います。確かに、ブラウザのタブにラベルがないと、たいていのユーザーはフラストレーションを感じるでしょう。しかし、それだけではなく、支援技術のユーザーにも影響が生じます。本書には<em>アクセシブルな名前 (accessible name)</em>の話がたびたび出てきます。これは支援技術とも互換性のあるラベルで、Webページのさまざまな要素に適用できます。ドキュメントや<code>&lt;iframe&gt;</code>、埋め込みのSVG要素では、それぞれに指定された<code>&lt;title&gt;</code>がアクセシブルな名前 (accessible name) となります。アクセシブルな名前 (accessible name) には、それら要素の内容と使用目的が書かれているべきです。</p><p><code>&lt;title&gt;</code>は新たにWebドキュメントが読み込まれるとすぐに読み上げられるため、ページの概要を示すのに最適です。一般的にはページの説明に、制作者とサイトの情報を付け加えます。たとえば「インクルーシブデザインテンプレート | ヘイドンのサイト」といった具合です。検索結果のページの場合は、「[Webサイト名] | [検索語句]の検索結果」のように、ユーザーが入力した検索語句を含めるようにしましょう。</p><h2><code>&lt;main&gt;</code> 要素</h2><p>本書で扱うパターンのうち、<em>ナビゲーション領域</em>などは、サイトの各ページにランドマークとして常に表示させるべきものです。そうではなく、ユニークなページを構成するコンテンツや、動的なコンテンツなどもあります。このようなコンテンツは、慣習的なWebページ構造では、メインコンテンツの領域に割り当てられます。</p><pre><code class=" language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>main</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span>"main"</span><span class="token punctuation">&gt;</span></span>
    <span class="token comment">&lt;!-- このページ独自のコンテンツ --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>main</span><span class="token punctuation">&gt;</span></span></code></pre><p>メインコンテンツという考え方自体は新しくはありませんが、メインコンテンツをヘッダー、ナビゲーション領域、フッターなどからインクルーシブに切り離せるようになったのは、つい最近のことです。<code>&lt;main&gt;</code>要素で定義された領域は、スクリーンリーダーに認識され、通知されます。JAWSなどのスクリーンリーダーには、<code>&lt;main&gt;</code>にアクセスするキーボードショートカット（<code>Q</code>キー）も用意されているため、ユーザーはページの前置きを飛ばして目的のコンテンツに直行できます。シングルページアプリケーションの場合、ひとつの<code>&lt;main&gt;</code>で、さまざまな機能が盛り込まれた各ビューをレンダリングすることになるでしょう。静的なブログやパンフレットの<code>&lt;main&gt;</code>には、ブログのポストやその他の情報コンテンツが含まれます。製品のページの場合は、<code>&lt;main&gt;</code>の中で製品説明を行います。</p><p><code>&lt;main&gt;</code>にページの主要コンテンツを入れる設計になったことで、印刷用スタイルシートを簡単に書けるようになりました。ナビゲーション、ヘッダー、フッター、サイドバー（<code>&lt;aside&gt;</code>）の領域がきちんと<code>&lt;main&gt;</code>の兄弟要素になっていれば、CSSでそれらをターゲットに指定するのは非常に簡単です。</p><pre><code class=" language-css"><span class="token atrule">@media print </span><span class="token punctuation">{</span>
    <span class="token selector">body &gt; *:not(main) </span><span class="token punctuation">{</span>
        <span class="token property">display</span><span class="token punctuation">:</span> none<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>私はWebページの印刷をしないタイプの人間です。10分も使うと必ず壊れるような家庭用プリンターには、とうの昔に見切りをつけました。しかし誰もがそうとは限りません。したがって印刷用のページには、画面でブラウズしているときにしか意味のない要素は含めない方が、親切かつインクルーシブなデザインと言えます。これは、Webをオフラインで読むための方法として、現在利用できる最も簡単なソリューションでもあります。読者は印刷結果をPDF出力して、ローカルディスクに保存することができるからです。</p><p><img src="images/print.png" alt="ページ内のコンテンツ部分を示す図。「重要な部分」というラベルの付いたボックスが、グレーアウトされた補助的なボックスに囲まれている。"/><br/><em>補助的なコンテンツを省けるようにするもうひとつのメリットは、画面で読むユーザーの体験が向上するということです。<a href="https://chrome.google.com/webstore/detail/stylish/fjnbnpbmkenffdnngjfgmeleoegfcffe?hl=en"><span class="caption-link">拡張機能</span></a>を使えばオリジナルのCSSをドメインベースで適用できます。</em></p>
<div class="translator_note" id="translator_note0481"><h3>訳註</h3><p>多くのブラウザには「ユーザースタイルシート」と呼ばれる機能があり、ユーザー側で定義したCSSで著者側のスタイルを上書きできるようになっています。しかし、その機能を持たないブラウザもありますし、機能があっても設定が大変だったり、全てのサイトに同一のユーザースタイルシートが適用されてしまうといった問題があり、かなり使いにくい側面があります。この拡張機能を使えば、ドメインごとにユーザースタイルシートを適用できるようになり、特定サイトのスタイルだけを変更することが簡単にできるようになります。</p></div>
<h3>スキップリンク</h3><p>スキップリンクは、インクルーシブデザインの名で作られた古典的なものです。その場しのぎの解決策に思えるかもしれませんが、一部のユーザーの体験に及ぼす効果は実証済みです。</p><p>スキップリンクはページの一番上に表示され、そこからメインコンテンツ領域にジャンプすることができます。しかし、これはいったい誰のためのものでしょう？典型的な答えは、スクリーンリーダーユーザーのためというものでした。しかし前述のように、スクリーンリーダーユーザーが<code>&lt;main&gt;</code>要素に移動する手段は他にもあります。スキップリンクの恩恵を最も受けるのは、目が見えているキーボードユーザーです。目が見えているキーボードユーザーには、スクリーンリーダーのようなショートカットの機能が提供されていません。ナビゲーションや他のヘッダーコンテンツをスキップする機能は、彼らのためのものなのです。</p>
<div class="translator_note" id="translator_note0488"><h4>訳註</h4><p>基本的な考え方はこのとおりですが、目の見えるキーボードユーザーは何らかの代替マウスの機能を使っていることが多く、コンテンツ内のスキップリンクを利用するニーズはあまりないのではないかという議論もあります。</p><h5>参考</h5><ul><li><a href="http://waic.jp/news/20130107.html">JIS X 8341-3:2010 達成基準7.2.4.1を満たす条件に関する意見募集</a></li><li><a href="http://waic.jp/news/20130422.html">JIS X 8341-3:2010 達成基準7.2.4.1を満たす条件に関する意見募集の結果について</a></li></ul></div>
<p>ただし、スキップリンクはデフォルトでは表示されないようにすべきです。マウスユーザーやタッチデバイスのユーザーにとっては非常に使いにくく、混乱を招くだけだからです。キーボードユーザーがスキップリンクを利用できるようにするため、以下のようにして、フォーカス時に表示されるようにしましょう。</p><pre><code class=" language-css"><span class="token selector">[href="#main"] </span><span class="token punctuation">{</span>
    <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>
    <span class="token property">top</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
    <span class="token property">right</span><span class="token punctuation">:</span> 100%<span class="token punctuation">;</span> <span class="token comment">/* 画面外に移動 */</span>
<span class="token punctuation">}</span>

<span class="token selector">[href="#main"]:focus </span><span class="token punctuation">{</span>
    <span class="token property">right</span><span class="token punctuation">:</span> auto<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>キーボードユーザーが新しいページに移動すると、まずそのドキュメント自体がフォーカスを受け取ります。その状態でユーザーが<em>Tab</em>キーを押すと、ページ内の最初のインタラクティブ要素、つまりスキップリンクがフォーカスされます。フォーカスがあたるとスキップリンクが画面に表示され、ユーザーは必要に応じてメインコンテンツにジャンプできるようになります。そしてもう一度Tabキーを押すとスキップリンクは非表示になり、ページ内の次のインタラクティブ要素（たいていはホームページへのリンクやナビゲーションリストの最初のリンク）にフォーカスが移ります。</p><h2>ページを見てみよう</h2><p>それでは、ここまで見てきたインクルーシブなドキュメントがどのような構成になったか見てみましょう。</p><pre><code class=" language-markup"><span class="token doctype">&lt;!DOCTYPE html&gt;</span>
<span class="token comment">&lt;!-- ページのメインの言語を指定  --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation">=</span>"en"</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span>"utf-8"</span><span class="token punctuation">&gt;</span></span>

        <span class="token comment">&lt;!-- ズームを無効にしないビューポート宣言 --&gt;</span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span>"viewport"</span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span>"width<span class="token punctuation">=</span>device-width, initial-scale<span class="token punctuation">=</span>1.0"</span><span class="token punctuation">&gt;</span></span>

        <span class="token comment">&lt;!-- レンダリングをブロックしない、Base64エンコードしたフォントリソース --&gt;</span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span>"stylesheet"</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span>"fonts.css"</span> <span class="token attr-name">media</span><span class="token attr-value"><span class="token punctuation">=</span>"none"</span> <span class="token attr-name">onload</span><span class="token attr-value"><span class="token punctuation">=</span>"if(media!<span class="token punctuation">=</span>'all')media<span class="token punctuation">=</span>'all'"</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>noscript</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span>"stylesheet"</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span>"fonts.css"</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>noscript</span><span class="token punctuation">&gt;</span></span>

        <span class="token comment">&lt;!-- レンダリングをブロックしないスタイルシート--&gt;</span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span>"stylesheet"</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span>"main.css"</span> <span class="token attr-name">media</span><span class="token attr-value"><span class="token punctuation">=</span>"none"</span> <span class="token attr-name">onload</span><span class="token attr-value"><span class="token punctuation">=</span>"if(media!<span class="token punctuation">=</span>'all')media<span class="token punctuation">=</span>'all'"</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>noscript</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span>"stylesheet"</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span>"main.css"</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>noscript</span><span class="token punctuation">&gt;</span></span>

        <span class="token comment">&lt;!-- ページの内容が分かるようなラベル --&gt;</span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>Inclusive Design Template | Heydon’s Site<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>
        <span class="token comment">&lt;!-- キーボードユーザーに便利なスキップリンク --&gt;</span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span>"#main"</span><span class="token punctuation">&gt;</span></span>メインコンテンツに移動<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span>

        <span class="token comment">&lt;!-- ロゴやページナビゲーションはここに --&gt;</span>

        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>main</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span>"main"</span><span class="token punctuation">&gt;</span></span>
            <span class="token comment">&lt;!-- このページ独自のコンテンツはここに --&gt;</span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>main</span><span class="token punctuation">&gt;</span></span>

        <span class="token comment">&lt;!-- レンダリングをブロックしないJavaScriptリソース --&gt;</span>
        <span class="token script"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span>"scripts.js"</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span></code></pre><h2>フレームワーク、プリプロセッサ、タスクランナーについての注意</h2><blockquote><p>開発者の作業しやすさより、ユーザーのニーズの方が重要だと私は思う。
<a href="https://aerotwist.com/blog/react-plus-performance-equals-what/"><span class="link">ポール・ルイス（Paul Lewis）</span></a></p></blockquote><p>Webデザイン関連の記事や本には、ワークフローの改善や、開発者側が楽をするための方法が書かれたものがたくさんあります。もし、フレームワークやプリプロセッサを利用して開発プロセスのスピードアップを図りたいと思う方がいらっしゃれば、それはご自由にどうぞ。しかし、本書は開発者のための本ではなく、ユーザーのための本です。</p><p>そのため、ユーザー体験をダイレクトに向上させることができるツールにのみ紙面を割いていきます。あらゆる状況を想定して、HTML、CSS、JavaScript、SVGといったWeb標準技術の可能性を探りましょう。こうした基本的な技術をユーザーが実際にどのように利用することになるのか。それを常に考えなければなりません（もちろん、ユーザーにメリットのある構成や記述のテクニックも大切です）。</p><p>ここで学んだことを生かしながら、十分に柔軟なフレームワークを利用すれば、優れたインターフェイスを記述、編成できます。インクルーシブデザインの手法に合うように調整することが容易でないような、柔軟性のないフレームワークは避けるべきです。そのようなフレームワークでは、残念な製品ができてしまうことになるでしょう。</p><p>目の前の重要な課題に集中するために、私は課題に点数をつけるようにしています。視覚的なデザインに取り組むときも、JavaScriptの動作を記述するときも、コンテンツを構築するときも、その<em>やり方</em>で恩恵を受けるのは誰かを必ず考えます。</p><p class="list"><span class="bullet">•</span><strong>1 点</strong>: 自分が恩恵を受ける</p><p class="list"><span class="bullet">•</span><strong>10 点</strong>: 自分と似た、同じ設定をしているユーザーや読者が恩恵を受ける</p><p class="list last-item"><span class="bullet">•</span><strong>100 点</strong>: 自分、自分と似たユーザー、<em>および</em>自分とは似つかない、異なる設定のユーザーや読者が恩恵を受ける</p><p>目指すは100点です。</p></div>
</body></html>